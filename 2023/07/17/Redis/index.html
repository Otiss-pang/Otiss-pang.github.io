<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis学习总结 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis学习总结介绍一下RedisRedis是一种基于内存的数据库，对数据的读写都是在内存中完成的，因此读写速度非常快，常用于缓存、消息队列、分布式锁等场景。Redis提供了多种数据结构来支持不同的业务场景，比如String、hash、list、set、zset、bitmaps（位图）、hyperLogLog（基数统计）、GEO（地理信息）、Steam（流），并且对数据的操作都是原子性的，因为执">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习总结">
<meta property="og:url" content="http://example.com/2023/07/17/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis学习总结介绍一下RedisRedis是一种基于内存的数据库，对数据的读写都是在内存中完成的，因此读写速度非常快，常用于缓存、消息队列、分布式锁等场景。Redis提供了多种数据结构来支持不同的业务场景，比如String、hash、list、set、zset、bitmaps（位图）、hyperLogLog（基数统计）、GEO（地理信息）、Steam（流），并且对数据的操作都是原子性的，因为执">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-17T14:21:17.000Z">
<meta property="article:modified_time" content="2023-07-18T03:18:40.792Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/17/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-18 11:18:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-17T14:21:17.000Z" title="Created 2023-07-17 22:21:17">2023-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-07-18T03:18:40.792Z" title="Updated 2023-07-18 11:18:40">2023-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis学习总结"><a href="#Redis学习总结" class="headerlink" title="Redis学习总结"></a>Redis学习总结</h1><h2 id="介绍一下Redis"><a href="#介绍一下Redis" class="headerlink" title="介绍一下Redis"></a>介绍一下Redis</h2><p>Redis是一种基于内存的数据库，对数据的读写都是在内存中完成的，因此读写速度非常快，常用于缓存、消息队列、分布式锁等场景。Redis提供了多种数据结构来支持不同的业务场景，比如String、hash、list、set、zset、bitmaps（位图）、hyperLogLog（基数统计）、GEO（地理信息）、Steam（流），并且对数据的操作都是原子性的，因为执行命令是单线程负责的，不存在并发竞争的问题。<br>除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制等等。</p>
<h2 id="Redis和Memcached的区别？"><a href="#Redis和Memcached的区别？" class="headerlink" title="Redis和Memcached的区别？"></a>Redis和Memcached的区别？</h2><p>相同点：</p>
<ul>
<li>都是基于内存的数据集，一般当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者性能都非常高</li>
</ul>
<p>不同点：</p>
<ul>
<li>Redis支持的数据类型更多（String、List、set、zset、hash），而Memcached只支持key-value数据类型。</li>
<li>Redis支持数据的持久化，Memcached不支持。</li>
<li>Redis原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持</li>
</ul>
<h2 id="为什么用redis做mysql的缓存？"><a href="#为什么用redis做mysql的缓存？" class="headerlink" title="为什么用redis做mysql的缓存？"></a>为什么用redis做mysql的缓存？</h2><p>主要是因为redis具有<strong>高性能</strong>和<strong>高并发</strong>的优点。</p>
<ol>
<li>高性能</li>
</ol>
<p>假如用户第一次访问mysql，因为要到硬盘去读取数据，过程比较慢。将该用户访问的数据放到redis中，第二次访问时直接从缓存中获取，操作redis缓存就是直接操作内存，所以速度相当快。</p>
<ol start="2">
<li>高并发</li>
</ol>
<p>单台设备的redis的QPS是mysql的10倍，redis的QPS能轻松破10万，而mysql都很难破1万。所以直接访问redis能够承受的请求远远大于mysql，可以考虑把部分mysql中的数据存到redis中，这样用户请求这一部分数据时就不用经过mysql。</p>
<h2 id="redis常用的数据结构以及使用场景？"><a href="#redis常用的数据结构以及使用场景？" class="headerlink" title="redis常用的数据结构以及使用场景？"></a>redis常用的数据结构以及使用场景？</h2><p>redis常用的数据结构有五种：String、List、Hash、Set、Zset<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689338982270-f3a7a398-d781-49b6-9e16-74ed26662909.png#averageHue=%23f0f1f3&clientId=u8af84d6d-70f1-4&from=paste&id=u7c3f0496&originHeight=600&originWidth=1500&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u95374f7e-6d3d-44ee-a73b-3e3f46d951c&title="><br>使用场景：</p>
<ul>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ul>
<h2 id="五种常见数据类型是怎么实现的"><a href="#五种常见数据类型是怎么实现的" class="headerlink" title="五种常见数据类型是怎么实现的?"></a>五种常见数据类型是怎么实现的?</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689340056518-8f0aee64-7cd2-4d82-a64a-2d3842954b05.png#averageHue=%23faf7ed&clientId=u8af84d6d-70f1-4&from=paste&id=u9c93cd0a&originHeight=830&originWidth=1352&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u575e1bb6-69de-4809-bf88-abc06dddfa2&title="></p>
<blockquote>
<p>String类型的内部实现</p>
</blockquote>
<p>String类型的底层实现是<strong>SDS（简单动态字符串）</strong>。SDS相比于C的原生字符串，主要优点有：</p>
<ul>
<li><strong>SDS不仅可以保存文本数据，还可以保持二进制数据。</strong></li>
<li><strong>SDS获取字符串长度的时间复杂度为O(1)。</strong>SDS结构里用len属性来记录字符串长度，所以复杂度O(1)。而C语言的字符串没有len属性，所以获取长度要O(n)。</li>
<li><strong>Redis的SDS API是安全的，拼接字符串不会造成缓冲区溢出。</strong>因为SDS在拼接时会首先判断SDS空间是否满足要求，如果空间不够会自动扩容。</li>
</ul>
<blockquote>
<p>List的内部实现</p>
</blockquote>
<p>List底层数据结构是由<strong>双向链表</strong>或者<strong>压缩列表</strong>实现的。</p>
<ul>
<li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<blockquote>
<p>Hash类型的底层实现</p>
</blockquote>
<p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<blockquote>
<p>Set类型内部实现</p>
</blockquote>
<p>Set类型的底层实现是由<strong>哈希表或者整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<blockquote>
<p>Zset类型的内部实现</p>
</blockquote>
<p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><h3 id="Redis是单线程吗？"><a href="#Redis是单线程吗？" class="headerlink" title="Redis是单线程吗？"></a>Redis是单线程吗？</h3><p>不是。<br>redis单线程指的是【接收客户端请求-&gt;解析请求-&gt;进行数据读写操作-&gt;发送数据给客户端】这个过程是由一个线程（主线程）来完成的。<br>但是redis程序并不是单线程的，redis在启动的时候，还会启动后台线程（BIO）。</p>
<ul>
<li>redis在2.6版本，会启动两个后台线程，分别处理<strong>关闭文件和AOF刷盘</strong>两个任务。</li>
<li>redis在4.0之后，新增了一个<strong>lazyfree线程</strong>，用来异步释放redis内存。</li>
</ul>
<p>之所以为关闭文件，AOF刷盘和释放内存单独创建线程，因为这几个任务都十分消耗时间，如果把它们放到主线程中，那么主线程就容易发生阻塞，就无法处理后续的请求了。<br>后台线程相当于一个消费者，生产者把耗时任务放到队列中，消费者（BIO）不断轮询这个队列，拿出任务就去执行对应的方法。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689344350285-6a7498bf-97ae-4ba3-a386-ec8de6c737de.png#averageHue=%23f7e6e4&clientId=u8af84d6d-70f1-4&from=paste&id=ubbe94e27&originHeight=834&originWidth=1282&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uab47cc82-ab57-4f09-a331-d05710c373c&title="></p>
<h3 id="redis采用单线程为什么还这么快"><a href="#redis采用单线程为什么还这么快" class="headerlink" title="redis采用单线程为什么还这么快"></a>redis采用单线程为什么还这么快</h3><p>redis的QPS能达到10w&#x2F;每秒级别，之所以这么快，原因如下：</p>
<ul>
<li>redis的大部分操作都在<strong>内存</strong>中执行。cpu不是redis的瓶颈，内存和网络带宽是瓶颈。</li>
<li>redis单线程模型可以<strong>避免多线程的竞争</strong>。省去的多线程切换时的开销。</li>
<li>redis采用了IO<strong>多路复用机制</strong>来处理socket请求，<strong>IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制</strong>。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果</li>
</ul>
<h3 id="redis6-0之后引入多线程"><a href="#redis6-0之后引入多线程" class="headerlink" title="redis6.0之后引入多线程"></a>redis6.0之后引入多线程</h3><p>redis6.0之后引入的多线程是用了多个<strong>I&#x2F;O线程来处理网络请求</strong>，这是因为随着网络硬件的性能提升，redis的瓶颈有时会出现在网络IO上，<strong>但是对于命令的执行，仍然是单线程的。</strong></p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="redis如何保证数据不丢失"><a href="#redis如何保证数据不丢失" class="headerlink" title="redis如何保证数据不丢失"></a>redis如何保证数据不丢失</h3><p>redis的数据是存在内存中的，每次重启redis，内存中的数据都会丢失。为了保证内存中的数据不丢失，redis实现了数据持久化的机制，将数据存到磁盘中，这样redis重启时就会从磁盘恢复原有的数据。<br>redis有三种持久化方式：</p>
<ul>
<li><strong>AOF日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里</li>
<li><strong>RDB快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>混合持久化</strong></li>
</ul>
<h3 id="AOF日志如何实现？"><a href="#AOF日志如何实现？" class="headerlink" title="AOF日志如何实现？"></a>AOF日志如何实现？</h3><p>Redis在执行一条命令时，会把该命令以追加的方式写到硬盘中，然后在redis重启时，会读取该文件的命令，然后逐一执行命令的方式来进行数据恢复。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689352964087-388b8244-2395-4b93-bb51-3207f28d1cdd.png#averageHue=%23f8f6f3&clientId=u62af6148-c8cd-4&from=paste&id=u81dc4c8b&originHeight=332&originWidth=902&originalType=url&ratio=1.375&rotation=0&showTitle=false&status=done&style=none&taskId=u77acb7b7-6729-4116-9777-81ff8dcf0cb&title="></p>
<h4 id="为什么先执行命令，再把数据写入日志呢？"><a href="#为什么先执行命令，再把数据写入日志呢？" class="headerlink" title="为什么先执行命令，再把数据写入日志呢？"></a>为什么先执行命令，再把数据写入日志呢？</h4><p>优点：</p>
<ul>
<li><strong>避免额外的检查开销</strong>：如果先将命令写入AOF日志，在执行命令的话，如果当前的命令出现了语法问题，那么如果不进行语法检查，该错误的命令记录到了AOF日志中的话，redis在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前写操作命令的执行：</strong>因为当写操作命令成功后，才会将命令写到AOF日志中。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据可能会丢失</li>
<li>可能阻塞其他操作</li>
</ul>
<h4 id="AOF日志的写回策略有几种"><a href="#AOF日志的写回策略有几种" class="headerlink" title="AOF日志的写回策略有几种"></a>AOF日志的写回策略有几种</h4><ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689411021268-4318d42e-471d-4fbe-9f88-cccf7baa3ae4.png#averageHue=%23edeae1&clientId=u6ead98e4-b5a9-4&from=paste&height=257&id=u51b8ad92&originHeight=362&originWidth=857&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=150175&status=done&style=none&taskId=u413397e9-cfd3-4613-8e3c-c7b6dfce3c4&title=&width=608.8000183105469" alt="image.png"></p>
<h3 id="RDB快照如何实现？"><a href="#RDB快照如何实现？" class="headerlink" title="RDB快照如何实现？"></a>RDB快照如何实现？</h3><p>AOF日志记录的是操作命令，不是实际的数据，所以用AOF日志时，需要将所有的命令都执行一遍，一旦日志非常多，就会造成redis的恢复操作十分缓慢。<br>为了解决这个问题，redis增加了<strong>RDB快照</strong>，RDB快照记录的是某一瞬间实际的内存数据。因此在redis恢复数据时，RDB快照恢复数据的效率会比AOF日志高些，因为直接将RDB文件读入内存就可以了，不用像AOF日志一样一条条去执行命令。</p>
<h4 id="RDB做快照时会阻塞线程吗"><a href="#RDB做快照时会阻塞线程吗" class="headerlink" title="RDB做快照时会阻塞线程吗"></a>RDB做快照时会阻塞线程吗</h4><p>redis提供了两个命令来生成RDB文件，<strong>save</strong>和<strong>bgsave</strong>。他们的区别在于是否是主线程里执行：</p>
<ul>
<li>执行了<strong>save</strong>命令，就会在主线程里生成RDB文件，由于和执行操作命令在同一个线程，如果写入RDB命令文件的时间太长，<strong>会阻塞主线程</strong>。</li>
<li>执行了<strong>bgsave</strong>命令，创建一个子进程来生成RDB文件，这样可以<strong>避免主线程的阻塞</strong>。</li>
</ul>
<blockquote>
<p>注意：redis的快照是<strong>全量快照</strong>，每次执行快照时，都是把内存中的所有数据记录到磁盘中。所以执行快照是一个比较重的操作。如果频率太频繁，可能会对redis性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
</blockquote>
<h4 id="RDB在执行的时候，数据能更改吗？"><a href="#RDB在执行的时候，数据能更改吗？" class="headerlink" title="RDB在执行的时候，数据能更改吗？"></a>RDB在执行的时候，数据能更改吗？</h4><p>可以滴！在执行bgsave的过程中，redis依然可以处理操作命令，也就是数据能被修改，关键的技术就是<strong>写时复制技术（Copy-On-Write, COW）</strong>。<br>执行bgsave命令时，会通过fork()命令创建子进程，此时子进程和主进程是共享同一片内存数据的，因为创建子进程时会复制主进程的页表，但是两个页表指向的物理内存都是同一个。</p>
<ul>
<li>如果此时主进程执行<strong>读操作</strong>，则主进程和bgsave子进程互相不影响。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689414020243-b0d468bc-108a-41c6-adce-b33d93db8655.png#averageHue=%23f8f7f4&clientId=u6ead98e4-b5a9-4&from=paste&height=505&id=u49d858e6&originHeight=707&originWidth=774&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=75728&status=done&style=none&taskId=u6a5eb1f7-cb4a-4f02-86bb-a0ca051296a&title=&width=552.8181762695312" alt="image.png"></p>
<ul>
<li>如果主进程执行<strong>写操作</strong>，则被修改的数据会复制一份副本，然后bgsave子进程会将副本数据写入RDB中，在这个过程中，原来的数据仍然能被主进程修改。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689414133546-4f8b4603-0707-418f-885a-8c46aed7a222.png#averageHue=%23faf9f6&clientId=u6ead98e4-b5a9-4&from=paste&height=483&id=u267bda5e&originHeight=707&originWidth=969&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=86749&status=done&style=none&taskId=uda94f70b-501f-45d5-bb3f-fcedbec9914&title=&width=661.4545288085938" alt="image.png"></p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>使用了混合持久化，<strong>AOF文件的前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据</strong>。<br><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689414658028-3ea9ee50-6015-40ce-817d-038c5022bcba.png#averageHue=%23faefcb&clientId=u6ead98e4-b5a9-4&from=paste&height=162&id=u1c2e3ef2&originHeight=356&originWidth=325&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=37352&status=done&style=none&taskId=ueb0e4e61-804b-4f0b-90d0-8e061868c95&title=&width=147.7272695253704" alt="image.png"></p>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="如何实现服务高可用？"><a href="#如何实现服务高可用？" class="headerlink" title="如何实现服务高可用？"></a>如何实现服务高可用？</h3><p>高可用要设计redis的多服务节点，比如redis的<strong>主从复制</strong>、<strong>哨兵模式</strong>、<strong>切片集群</strong>。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>redis高可用的基础保证就是主从复制，将从前的一台redis服务器，同步数据到多台从服务器中，即<strong>一主多从</strong>的模式，且主从服务器之间采用的是「<strong>读写分离</strong>」的方式。<br><strong>所有的数据修改都只在主服务器上进行，然后将最新的数据同步给从服务器，这样使得主从服务器的数据一致。</strong><br>主从服务器之间的命令复制是<strong>异步</strong>的。主服务器收到新的写命令后，会发送给从服务器。但是，从服务器并不会等到服务器实际执行完命令之后，再把结果返回给客户端，而是主服务器自己本地执行完命令之后机会向客户端返回结果。<strong>如果从服务器还没执行完主服务器同步过来的命令，主从服务器之间的数据就会不一致。</strong><br><strong>所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689424465357-4ad8e48f-3cb7-412c-904b-65870dbaa85c.png#averageHue=%23f9f7f5&clientId=u6ead98e4-b5a9-4&from=paste&height=192&id=uccdfa5c4&originHeight=422&originWidth=902&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=101427&status=done&style=none&taskId=u974aa98f-829f-4eb6-acf0-03f03166bec&title=&width=409.9999911134895" alt="image.png"></p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>在使用主从服务时，当redis的主从服务器出现故障宕机时，需要手动进行恢复。为了解决这个问题，redis增加了哨兵模式（<strong>Redis Sentinel</strong>），因为哨兵模式做到了可以监控主从服务器，并且提供了<strong>主从节点故障转移的功能。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689425480731-f976dace-61bb-477c-af2e-a73c1666a281.png#averageHue=%23f7f5f3&clientId=u6ead98e4-b5a9-4&from=paste&height=255&id=u186e00c8&originHeight=560&originWidth=982&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=116224&status=done&style=none&taskId=u2753fe90-0f67-4c57-ae46-ba99ede33d2&title=&width=446.3636266889653" alt="image.png"></p>
<h4 id="切片集群模式（Redis-Cluster）"><a href="#切片集群模式（Redis-Cluster）" class="headerlink" title="切片集群模式（Redis Cluster）"></a>切片集群模式（Redis Cluster）</h4><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p>
<h3 id="集群脑裂导致数据丢失怎么办？"><a href="#集群脑裂导致数据丢失怎么办？" class="headerlink" title="集群脑裂导致数据丢失怎么办？"></a>集群脑裂导致数据丢失怎么办？</h3><ol>
<li>什么是脑裂？</li>
</ol>
<p>由于网络问题，主节点与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，客户端仍然在向主节点写入数据，此时这些数据被旧主节点缓存在缓冲区中，因为主从节点间的网络问题，这些数据都是无法同步给从节点的。<br>这时，哨兵也发现了主节点失联了，它就认为主节点挂了，从剩下的从节点中选出一个节点作为新的主节点（leader），这时集群就出现了<strong>两个主节点–脑裂。</strong><br>然后，网络突然好了，哨兵会将原来的主节点降级为从节点，然后这个原来的主节点（现在的从节点）会向新的主节点请求数据同步。因为第一次同步是<strong>全量同步</strong>的方式，此时的从节点会清除自己本地的数据，然后再做全量同步。所以，之前客户端写入原来的主节点的数据就会丢失了，就是集<strong>群产生脑裂导致数据丢失的问题</strong>。</p>
<ol start="2">
<li>解决方法</li>
</ol>
<p>脑裂出现的主要原因是哨兵集群认为主节点已经出现故障了，重新选举其他节点作为主节点，但是主节点的故障是假故障。<strong>所以应对脑裂的方法是限制去原主库接收请求</strong>，redis提供了两个配置项：</p>
<ul>
<li>min-slaves-to-write：与主节点通信的从节点数量必须大于等于该值主节点，否则主节点拒绝写入。</li>
<li>min-slaves-max-lag：主节点与从节点通信的ACK消息延迟必须小于该值，否则主节点拒绝写入。</li>
</ul>
<p>这两个配置项必须同时满足，不然主节点拒绝写入。<br><strong>脑裂无法彻底解决，</strong>因为redis的主从集群内部没有共识算法来维护多个节点的强一致性，他不像Zookeeper那样，每次写入大多数节点成功后才算成功，当脑裂发生时，Zookeeper节点被孤立，此时无法写入大多数节点，写请求会直接失败，因此Zookeeper才能保证集群的强一致性。</p>
<h2 id="Redis过期删除和内存淘汰"><a href="#Redis过期删除和内存淘汰" class="headerlink" title="Redis过期删除和内存淘汰"></a>Redis过期删除和内存淘汰</h2><h3 id="redis使用的过期删除策略是什么？"><a href="#redis使用的过期删除策略是什么？" class="headerlink" title="redis使用的过期删除策略是什么？"></a>redis使用的过期删除策略是什么？</h3><p>redis使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」。可以看到，惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p>
<ul>
<li><strong>惰性删除策略</strong>：<strong>不主动删除过期键，每次从数据库访问key时，都检测key是否过期，如果过期则删除该key</strong>。</li>
</ul>
<p><strong>优点</strong>：每次访问时才会检测key是否过期，所以只会使用很少的系统资源，因此，惰性删除策略对cpu友好。<br><strong>缺点</strong>：过期了的key仍然保留在数据库中，造成内存空间浪费。所以，惰性删除对内存不友好。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689429305369-ee298691-a7f3-4fae-a59f-264db54baff3.png#averageHue=%23f6f0ea&clientId=u6ead98e4-b5a9-4&from=paste&height=704&id=u0d02005f&originHeight=1549&originWidth=910&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=193540&status=done&style=none&taskId=u90f25943-6064-410d-a215-07000340c54&title=&width=413.6363546710371" alt="image.png"></p>
<ul>
<li><strong>定期删除策略：每隔一段时间随机从数据库中取出一定数量的key进行检查，并删除其中的过期key。</strong></li>
</ul>
<p>Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689429558629-f795b8c4-6ea2-4517-8aef-123530466864.png#averageHue=%23f8f6ef&clientId=u6ead98e4-b5a9-4&from=paste&height=623&id=u94f3fd93&originHeight=2399&originWidth=1041&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=275573&status=done&style=none&taskId=u6e9e6a12-171c-477e-8193-5d0745ec4cb&title=&width=270.1817932128906" alt="image.png"></p>
<h3 id="Redis的内存淘汰策略有哪些？"><a href="#Redis的内存淘汰策略有哪些？" class="headerlink" title="Redis的内存淘汰策略有哪些？"></a>Redis的内存淘汰策略有哪些？</h3><p><em><strong>1、不进行数据淘汰的策略</strong></em><br><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。<br><em><strong>2、进行数据淘汰的策略</strong></em><br>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ul>
<h2 id="Redis缓存设计"><a href="#Redis缓存设计" class="headerlink" title="Redis缓存设计"></a>Redis缓存设计</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>通常redis中的数据都会设一个过期时间，当缓存数据过期后，用户访问的数据不在redis缓存中，业务系统会重新生成缓存，此时会访问数据库，并将数据更新到redis中，这样后续请求都可以直接命中redis缓存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689431789168-07915444-ca73-4e07-96ef-5f7f45382bde.png#averageHue=%23f3f1ef&clientId=u6ead98e4-b5a9-4&from=paste&height=199&id=ue10bd175&originHeight=438&originWidth=692&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=72666&status=done&style=none&taskId=u2ba2a809-56fe-4012-97ba-496393bdb1f&title=&width=314.54544772786556" alt="image.png"><br><strong>当大量的缓存数据在同一时刻过期（失效）时，此时如果有大量的用户请求，都无法在redis中处理，于是这些请求会全部访问数据库，从而导致数据库的压力骤增，严重会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩。</strong><br><strong>解决方法：</strong></p>
<ol>
<li><strong>将缓存失效时间随机打散：</strong>我们可以在原有的失效时间基础上增加一个随机值，这样每个缓存的过期时间就不会重复了，降低了缓存集体失效的概率。</li>
<li><strong>设置缓存不过期：</strong>通过后台服务来更新缓存，从而避免因为缓存失效造成的缓存雪崩。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>redis缓存中的<strong>某个热点数据（被频繁访问的数据）过期了</strong>，此时大量的请求访问了该热点数据，就无法从缓存中读取，将直接访问数据集，数据库很容易被高并发的请求击垮，这就是<strong>缓存击穿</strong>问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689431915584-aece0357-0ef7-4867-b21d-aca40979f600.png#averageHue=%23f9f1e5&clientId=u6ead98e4-b5a9-4&from=paste&height=380&id=ufb17ebf1&originHeight=836&originWidth=707&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=187064&status=done&style=none&taskId=u6c5767b4-a1d7-430e-85e1-57d7665eb7a&title=&width=321.3636293982673" alt="image.png"><br>解决方法：</p>
<ul>
<li><strong>互斥锁方案</strong>（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li><strong>不给热点数据设置过期时间</strong>，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当用户访问的数据，<strong>既不在缓存中，又不在数据库</strong>中，导致请求在访问缓存时发现缓存缺失，再去访问数据库，发现数据库中也没有要访问的数据，没办法构建缓存数据来服务后续的请求。那么当有大量的这样的请求来到时，数据库的压力骤增，这就是<strong>缓存穿透问题</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689432267758-f79d9ef5-97ef-4b21-b8f9-48331aef4e3e.png#averageHue=%23f8efe3&clientId=u6ead98e4-b5a9-4&from=paste&height=380&id=ua4438a77&originHeight=836&originWidth=576&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=168295&status=done&style=none&taskId=ueb968cff-2853-4de2-be3e-cc854a93637&title=&width=261.81817614342566" alt="image.png"><br>解决方法：</p>
<ul>
<li><strong>非法请求的限制</strong>：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li>
<li><strong>设置空值或者默认值</strong>：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li>
<li><strong>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</strong>：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li>
</ul>
<h3 id="如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>如何设计一个缓存策略，可以动态缓存热点数据呢？</h3><p>通过数据<strong>最新访问时间</strong>来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。<br>比如设计一个电商平台中缓存只存用户经常访问的Top 1000的商品：</p>
<ul>
<li>先通过缓存做一个排序队列，存放1000件商品，系统会根据最近访问时间做一个排序，越是访问时间越近的排在越前面；</li>
<li>同时系统会定时过滤掉最后200个商品，然后再从数据库随机选200个商品进入缓存队列中；</li>
<li>这样当请求每次到达时，会先从队列中获取商品ID，如果命中，就根据ID再从另一个缓存数据结构中读取实际的商品信息并返回。</li>
</ul>
<p>在redis中可以用zadd方法和zrange方法来完成排序队列和获取200个商品的操作。</p>
<h3 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h3><ul>
<li>Cache Aside（旁路缓存）策略</li>
<li>Read&#x2F;Write Through（读穿&#x2F;写穿）</li>
<li>Write Back（写回）</li>
</ul>
<p>实际开发中用的是Cache Aside策略。</p>
<ol>
<li>Cache Aside策略</li>
</ol>
<p>应用程序直接与数据库、缓存交互，并负责对缓存的维护，该策略又可以细分为读策略和写策略。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689507018395-72d2e0c9-aa9c-45c2-b2b9-5dc0bb83849d.png#averageHue=%23f8f5ee&clientId=u6ead98e4-b5a9-4&from=paste&height=281&id=u3ac86acb&originHeight=618&originWidth=731&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=139757&status=done&style=none&taskId=uf52e8e3e-bbd6-4a6e-bd5b-d803fe3e703&title=&width=332.27272007091" alt="image.png"><br><strong>写策略的步骤：</strong></p>
<ul>
<li>先更新数据库中的数据，再删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<p>注意，写策略的步骤的顺序不能倒过来，即<strong>不能先删除缓存再更新数据库</strong>，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。</p>
<h3 id="！！！如何保证缓存和数据库数据一致性"><a href="#！！！如何保证缓存和数据库数据一致性" class="headerlink" title="！！！如何保证缓存和数据库数据一致性"></a>！！！如何保证缓存和数据库数据一致性</h3><p>引入了缓存，那么在更新数据时，也要更新缓存，这两个更新操作存在前后顺序的问题，也就是说依然存在由并发操作所带来的问题：</p>
<ol>
<li>先更新数据库，再更新缓存；</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689510558331-9f40e874-dea8-4927-a7b8-0ffe4da53da2.png#averageHue=%23f9f6ef&clientId=u6ead98e4-b5a9-4&from=paste&height=281&id=ub528bc44&originHeight=618&originWidth=893&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=132103&status=done&style=none&taskId=u5c616101-7eb7-4114-aa4b-3a8a3589b3f&title=&width=405.9090821112485" alt="image.png"><br>可以看到，此时数据库数据为2，缓存数据为1，<strong>数据不一致</strong>。</p>
<ol start="2">
<li>先更新缓存，再更新数据库；</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689510638794-911fb6a5-bf09-4313-9a3c-17f6622a251c.png#averageHue=%23f8f4ec&clientId=u6ead98e4-b5a9-4&from=paste&height=226&id=ub0105aba&originHeight=498&originWidth=903&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=126066&status=done&style=none&taskId=ue2076afc-8dc8-45a6-83f2-f5fc38ba032&title=&width=410.45453655818295" alt="image.png"><br>数据库数据为1，缓存数据为2，出现了缓存和数据库中的数据不一致的问题。<br>在更新数据时，<strong>不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。这个策略是Cache Aside策略。</strong></p>
<ol>
<li><strong>先删除缓存，在更新数据库</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689510845363-61f7784e-d1c6-4e2a-9918-a159f3f4fb90.png#averageHue=%23f9f4ee&clientId=u6ead98e4-b5a9-4&from=paste&height=281&id=uba29a483&originHeight=618&originWidth=903&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=146284&status=done&style=none&taskId=u833a9dfe-a93e-4911-97ab-c737b03dcd8&title=&width=410.45453655818295" alt="image.png"><br>仍然存在缓存和数据库的数据不一致性。</p>
<ol start="2">
<li><strong>先更新数据库，再删除缓存</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689510902417-4971fc75-dc53-4acd-9694-9c8ed4104250.png#averageHue=%23f9f5ed&clientId=u6ead98e4-b5a9-4&from=paste&height=281&id=u7923d0dd&originHeight=618&originWidth=902&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=147708&status=done&style=none&taskId=uc9e72514-bd0d-494e-a412-4039de2d738&title=&width=409.9999911134895" alt="image.png"><br>从理论上说，先更新数据库，再删除缓存还是会出现数据不一致的问题，<strong>但在实际中，这个问题出现的概率并不高。因为缓存写入通常远远快于数据库的写入。</strong></p>
<p><strong>如何保证「先更新数据库，在删除缓存」这两个操作都能执行成功呢？</strong></p>
<ol>
<li><strong>重试机制</strong></li>
</ol>
<p>可以引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<ul>
<li>如果<strong>删除缓存操作失败</strong>，那么从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。重试超过一定次数，需要向业务层发送错误消息。</li>
<li>如果<strong>删除成功</strong>，那么将数据从消息队列中移除，避免重复操作。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689511665535-691759a3-b586-4395-8990-32a511bcf5b0.png#averageHue=%23fbfaf8&clientId=u6ead98e4-b5a9-4&from=paste&height=210&id=u16bcacc7&originHeight=462&originWidth=1080&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=112296&status=done&style=none&taskId=u187fd483-4a31-4f3e-9781-26339940d82&title=&width=490.90908026892316" alt="image.png"></p>
<ol start="2">
<li><strong>订阅Mysql binlog，再操作缓存</strong></li>
</ol>
<p><strong>第一步更新数据库会产生一条binlog日志，可以通过订阅binlog日志，拿到具体要操作的数据，然后再执行缓存删除。</strong><br><strong>阿里巴巴的canal中间件就是基于这个实现的。</strong><br>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。<br>下图是 Canal 的工作原理：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689511857687-9350f85e-d8b1-403f-ab83-6fa860bf9c07.png#averageHue=%23f7f6f4&clientId=u6ead98e4-b5a9-4&from=paste&id=u890cde42&originHeight=332&originWidth=782&originalType=url&ratio=2.200000047683716&rotation=0&showTitle=false&size=49724&status=done&style=none&taskId=u77bad9eb-8c54-45b3-8146-c36763a5fb0&title=" alt="image.png"><br>所以<strong>，</strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「<strong>消息队列来重试缓存的删除</strong>」，或者「<strong>订阅 MySQL binlog 再操作缓存</strong>」，这两种方法有一个共同的特点，都是采用<strong>异步操作</strong>缓存。</p>
<h2 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h2><h3 id="Redis如何实现延迟队列"><a href="#Redis如何实现延迟队列" class="headerlink" title="Redis如何实现延迟队列"></a>Redis如何实现延迟队列</h3><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li>
</ul>
<p>在 Redis 可以使用<strong>有序集合（ZSet）</strong>的方式来实现延迟消息队列的，ZSet 有一个 <strong>Score</strong> 属性可以用来存储延迟执行的时间。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689512166205-10442ac6-a27b-4b04-af38-392407141f11.png#averageHue=%23f0f0ef&clientId=u6ead98e4-b5a9-4&from=paste&height=135&id=ue14879d6&originHeight=145&originWidth=632&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=49975&status=done&style=none&taskId=u9197dd6e-837e-4d08-9939-026313dc38f&title=&width=587.272705078125" alt="image.png"><br>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p>
<h3 id="Redis的大key如何处理？"><a href="#Redis的大key如何处理？" class="headerlink" title="Redis的大key如何处理？"></a>Redis的大key如何处理？</h3><blockquote>
<p>什么是大key？</p>
</blockquote>
<p><strong>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</strong><br>一般而言，下面这两种情况被称为大 key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li>
</ul>
<blockquote>
<p>大key会造成什么问题？</p>
</blockquote>
<p>大 key 会带来以下四种影响：</p>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<blockquote>
<p>如何找到大key</p>
</blockquote>
<p><em><strong>1、redis-cli –bigkeys 查找大key</strong></em><br><em><strong>2、使用 SCAN 命令查找大 key</strong></em><br><em><strong>3、使用 RdbTools 工具查找大 key</strong></em></p>
<blockquote>
<p><em><strong>如何删除大key</strong></em></p>
</blockquote>
<h3 id="Redis管道有什么用？"><a href="#Redis管道有什么用？" class="headerlink" title="Redis管道有什么用？"></a>Redis管道有什么用？</h3><p>Pipeline是客户端提供的一种批处理技术，用于一次性处理多个Redis命令，从而提高整个交互的性能。<br>普通命令模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689513026612-a092e86e-47d1-4428-9890-a187c2c3a78d.png#averageHue=%23f5efdb&clientId=u6ead98e4-b5a9-4&from=paste&height=164&id=ue33b887c&originHeight=360&originWidth=804&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=46473&status=done&style=none&taskId=u806e0e4b-77ef-4a60-8ca6-a499a5055c2&title=&width=365.45453753353166" alt="image.png"><br>管道模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689513042479-436c3bce-2554-4115-a3a8-45b6fb6e7018.png#averageHue=%23f5efdb&clientId=u6ead98e4-b5a9-4&from=paste&height=164&id=u3c17b1fa&originHeight=360&originWidth=804&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=43123&status=done&style=none&taskId=u99940fb0-b192-48df-84fb-42e8ce08bd9&title=&width=365.45453753353166" alt="image.png"><br>使用<strong>管道技术可以解决多个命令执行时的网络等待</strong>。它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。<br>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。<br>要注意的是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p>
<h3 id="Redis事务支持回滚吗？"><a href="#Redis事务支持回滚吗？" class="headerlink" title="Redis事务支持回滚吗？"></a>Redis事务支持回滚吗？</h3><p><strong>Redis 中并没有提供回滚机制</strong>，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p>
<h3 id="如何用Redis实现分布式锁"><a href="#如何用Redis实现分布式锁" class="headerlink" title="如何用Redis实现分布式锁"></a>如何用Redis实现分布式锁</h3><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。<br>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27173335/1689513906987-c32f7dad-027b-4f38-b9a8-57e932ffcd00.png#averageHue=%23faf9f9&clientId=u1e9ddd3a-2133-4&from=paste&height=306&id=uc247460d&originHeight=674&originWidth=1454&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=171986&status=done&style=none&taskId=u8d822355-5597-40f7-a405-724f52ec57a&title=&width=660.9090765842725" alt="image.png"><br><strong>Redis分布式锁的优缺点？</strong><br><strong>07月16日 TODO</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/17/Redis/">http://example.com/2023/07/17/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/18/JVM/" title="JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JVM</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/17/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/07/18/JVM/" title="JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-18</div><div class="title">JVM</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Redis学习总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BRedis"><span class="toc-number">1.1.</span> <span class="toc-text">介绍一下Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Redis和Memcached的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8redis%E5%81%9Amysql%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">为什么用redis做mysql的缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">redis常用的数据结构以及使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">五种常见数据类型是怎么实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">Redis线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">Redis是单线程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">1.6.2.</span> <span class="toc-text">redis采用单线程为什么还这么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis6-0%E4%B9%8B%E5%90%8E%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">redis6.0之后引入多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.7.1.</span> <span class="toc-text">redis如何保证数据不丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%97%A5%E5%BF%97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">AOF日志如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%86%8D%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E5%91%A2%EF%BC%9F"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">为什么先执行命令，再把数据写入日志呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">AOF日志的写回策略有几种</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%BF%AB%E7%85%A7%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">RDB快照如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%81%9A%E5%BF%AB%E7%85%A7%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">RDB做快照时会阻塞线程吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%83%BD%E6%9B%B4%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">RDB在执行的时候，数据能更改吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.7.4.</span> <span class="toc-text">混合持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">1.8.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">如何实现服务高可用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Redis-Cluster%EF%BC%89"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">切片集群模式（Redis Cluster）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.8.2.</span> <span class="toc-text">集群脑裂导致数据丢失怎么办？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">1.9.</span> <span class="toc-text">Redis过期删除和内存淘汰</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">redis使用的过期删除策略是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">Redis的内存淘汰策略有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.10.</span> <span class="toc-text">Redis缓存设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.10.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.10.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.10.3.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-number">1.10.4.</span> <span class="toc-text">如何设计一个缓存策略，可以动态缓存热点数据呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.10.5.</span> <span class="toc-text">常见的缓存更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%81%EF%BC%81%EF%BC%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.10.6.</span> <span class="toc-text">！！！如何保证缓存和数据库数据一致性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%9E%E6%88%98"><span class="toc-number">1.11.</span> <span class="toc-text">Redis实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">1.11.1.</span> <span class="toc-text">Redis如何实现延迟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%A4%A7key%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.11.2.</span> <span class="toc-text">Redis的大key如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.11.3.</span> <span class="toc-text">Redis管道有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97%EF%BC%9F"><span class="toc-number">1.11.4.</span> <span class="toc-text">Redis事务支持回滚吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.11.5.</span> <span class="toc-text">如何用Redis实现分布式锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/JVM/" title="JVM">JVM</a><time datetime="2023-07-18T03:08:10.000Z" title="Created 2023-07-18 11:08:10">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/Redis/" title="Redis学习总结">Redis学习总结</a><time datetime="2023-07-17T14:21:17.000Z" title="Created 2023-07-17 22:21:17">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/hello-world/" title="Hello World">Hello World</a><time datetime="2023-07-17T14:18:45.527Z" title="Created 2023-07-17 22:18:45">2023-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>